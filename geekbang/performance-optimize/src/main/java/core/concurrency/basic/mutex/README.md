明确锁的范围，能够锁住的资源。 可能容易问题的地方： 1、锁住了错误的资源 2、锁的粒度太大，锁住的资源太多，导致性能太低

锁是一种通用的技术方案，Java 语言提供的 synchronized 关键字，就是锁的一种实现。
管程中锁的规则：对一个锁的解锁 Happens-Before 于后续对这个锁的加锁。

如果资源之间有关联关系，就要选择一个粒度更大的锁，这个锁应该能够覆盖所有相关的资源。

“原子性”的本质是什么？其实不是不可分割，不可分割只是外在表现，其本质是多个资源间有一致性的要求，操作的中间状态对外不可见。
例如，在 32 位的机器上写 long 型变量有中间状态（只写了 64 位中的 32 位），在银行转账的操作中也有中间状态（账户 A 减少了 100，账户 B 还没来得及发生变化）。
所以解决原子性问题，是要保证中间状态对外不可见

锁，应是私有的、不可变的、不可重用的，所以Integer 和 String 类型的对象不适合做锁，因为使用了享元模式，Integer 和 String 类型的对象是可重用的。



1. 通过 CPU 的堆栈寄存器。CPU 支持一种栈结构，因为这个栈是和方法调用相关的，因此经常被称为调用栈 
2. 每个方法在调用栈里都有自己的独立空间，称为栈帧 
3. 栈帧和方法是同生共死的 
4. 局部变量就是放到了调用栈的栈帧里 
5. 局部变量是和方法同生共死的，一个变量如果想跨越方法的边界，就必须创建在堆里 
6. 每个线程都有自己独立的调用栈

方法里的局部变量，因为不会和其他线程共享，所以没有并发问题，这个思路很好，已经成为解决并发问题的一个重要技术，同时还有个响当当的名字叫做线程封闭，比较官方的解释是：仅在单线程内访问数据。由于不存在共享，所以即便不同步也不会有并发问题，性能杠杠的。

采用线程封闭技术的案例非常多，例如从数据库连接池里获取的连接 Connection，在 JDBC 规范里并没有要求这个 Connection 必须是线程安全的。
数据库连接池通过线程封闭技术，保证一个 Connection 一旦被一个线程获取之后，
在这个线程关闭 Connection 之前的这段时间里，不会再分配给其他线程，从而保证了 Connection 不会有并发问题。
搜索ThreadLocal jdbc connection，了解详细实现

将递归转化为迭代，如果无法转化，-Xss参数可以调整栈大小，但也不能无限大，对递归要有一定的判断，深度最深会多深，根据这个调用深度来设置足够大小的空间。

栈溢出原因：
因为每调用一个方法就会在栈上创建一个栈帧，方法调用结束后就会弹出该栈帧，而栈的大小不是无限的，所以递归调用次数过多的话就会导致栈溢出。而递归调用的特点是每递归一次，就要创建一个新的栈帧，而且还要保留之前的环境（栈帧），直到遇到结束条件。所以递归调用一定要明确好结束条件，不要出现死循环，而且要避免栈太深。
解决方法：
1. 简单粗暴，不要使用递归，使用循环替代。缺点：代码逻辑不够清晰；
2. 限制递归次数；
3. 使用尾递归，尾递归是指在方法返回时只调用自己本身，且不能包含表达式。编译器或解释器会把尾递归做优化，使递归方法不论调用多少次，都只占用一个栈帧，所以不会出现栈溢出。然鹅，Java没有尾递归优化。


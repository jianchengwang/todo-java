代理模式（Proxy Design Pattern）的原理和代码实现都不难掌握。它在不改变原始类（或叫被代理类）代码的情况下，通过引入代理类来给原始类附加功能。

## 静态代理

静态代理的特点如下：

1. 使用静态代理时，通常客户类不需要感知RealSubject。
2. 静态代理的缺点：代理对象需要与目标对象实现一样的接口，因此接口较多时需要定义和维护大量的代理类代码。
3. 与适配器的差异：适配器通常考虑改变接口形态，而代理则不会也不能改变接口形态。
4. 与装饰器的差异：被代理对象由代理对象创建，客户端甚至不需要知道被代理类的存在；被装饰对象则由客户端创建并传给装饰对象，可以层层嵌套，层层装饰。代理模式常用于控制被代理对象的访问，而装饰模式是增加被装饰者的功能

## 动态代理

所谓动态代理（Dynamic Proxy），就是我们不事先为每个原始类编写代理类，而是在运行的时候，动态地创建原始类对应的代理类，然后在系统中用代理类替换掉原始类。

因为 Java 语言本身就已经提供了动态代理的语法（实际上，动态代理底层依赖的就是 Java 的反射语法）

Spring AOP对于实现接口类是采用上述JDK动态代理实现，而没有实现接口的类是采用cglib增强类来实现，具体实现逻辑和上述采用继承进行代理类似

### JDK 动态代理

JDK动态代理所用到的代理对象，在程序运行阶段调用到代理类对象时才由JVM真正创建。

JVM根据传进来的业务实现类对象及方法名，在内存中动态地创建一个代理类的class文件并被字节码引擎执行，然后通过该代理类对象进行方法调用。

具体而言，每个代理类的对象都会关联一个表示内部处理逻辑的InvocationHandler接口的实现。

当使用者调用代理对象所代理的接口中的方法时，这个调用的信息会被传递给InvocationHandler的invoke方法。

特点：
1. 通过实现InvocationHandler接口完成代理逻辑。
2. 通过反射代理方法，比较消耗系统性能，但可以减少代理类的数量，使用更灵活。
3. 代理类必须实现接口。

### cglib代理

CGLIB(Code Generation Library)是一个基于ASM的字节码生成库，它允许我们在运行时对字节码进行修改和动态生成。

Cglib(Code Generation Library)是个功能强大、高性能、开源的代码生成包，它可以为没有实现接口的类提供代理。具体而言，Cglib继承被代理的类，覆写其业务方法来实现代理。因为采用继承机制，所以不能对final修饰的类进行代理。

### spring aop

## 代理模式的应用场景
1. 业务系统的非功能性需求开发，比如：监控、统计、鉴权、限流、事务、幂等、日志。
2. 跨系统的接口调用、中间件的使用，比如：RPC、缓存中间件、消息中间件。
3. 业务系统的边界处，比如：分布式事务的一致性（2PC、TCC）、远程方法调用的幂等性设计（利用唯一ID）。

